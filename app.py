import os
import json
import logging
import requests
from flask import Flask, render_template, request, redirect, url_for
from flask_socketio import SocketIO, emit
import nmap
import dns.resolver
import whois

app = Flask(__name__)
app.config['UPLOAD_FOLDER'] = 'uploads'
app.config['RESULTS_FOLDER'] = 'results'
app.config['SECRET_KEY'] = 'supersecretkey'
socketio = SocketIO(app)

# Create results folder if it doesn't exist
os.makedirs(app.config['RESULTS_FOLDER'], exist_ok=True)

# Configure logging
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

def extract_domain(url):
    logger.debug(f"Extracting domain from URL: {url}")
    domain = url.split('//')[-1].split('/')[0]
    logger.debug(f"Extracted domain: {domain}")
    return domain

def perform_port_scan(domain):
    logger.debug(f"Starting port scan for domain: {domain}")
    nm = nmap.PortScanner()
    scan_result = nm.scan(domain, '1-65535')
    logger.debug(f"Port scan results: {scan_result}")
    return scan_result

def get_vulnerabilities(port, username, password):
    logger.debug(f"Fetching vulnerabilities for port: {port}")
    vulnerabilities = []
    try:
        response = requests.get(f'https://www.opencve.io/api/cve?search={port}', auth=(username, password))
        if response.status_code == 200:
            vulnerabilities = response.json()  # Assuming the response is a list
            logger.debug(f"Vulnerabilities found: {vulnerabilities}")
        else:
            logger.error(f"Failed to fetch vulnerabilities: {response.status_code} {response.text}")
    except Exception as e:
        logger.error(f"Error getting vulnerabilities: {e}")
    return vulnerabilities

def save_to_json(data, domain, folder='results'):
    filename = f"{domain.replace('.', '_')}_vulnerabilities.json"
    filepath = os.path.join(folder, filename)
    logger.debug(f"Saving data to {filepath}")
    with open(filepath, 'w') as json_file:
        json.dump(data, json_file, indent=4)
    logger.debug(f"Data saved to {filepath}")

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/upload', methods=['GET', 'POST'])
def upload():
    if request.method == 'POST':
        if 'file' not in request.files:
            return redirect(request.url)
        file = request.files['file']
        if file.filename == '':
            return redirect(request.url)
        if file and file.filename.endswith('.json'):
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
            file.save(file_path)
            return redirect(url_for('analyze_file', filename=file.filename))
    return render_template('upload.html')

@app.route('/analyze/<filename>')
def analyze_file(filename):
    file_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)
    try:
        data = load_json(file_path)
        extracted_data = extract_data(data)
        domain = extract_domain(extracted_data.get('url'))
        dns_info = get_dns_info(domain)
        port_scan = perform_port_scan(domain)
        vulnerabilities = []
        ip_address = dns_info[0] if dns_info else domain
        if 'scan' in port_scan and ip_address in port_scan['scan'] and 'tcp' in port_scan['scan'][ip_address]:
            for port in port_scan['scan'][ip_address]['tcp']:
                vulns = get_vulnerabilities(port, 'darth_daddio', '3p$ALN9$bhVzn6f')
                vulnerabilities.extend(vulns)
        else:
            logger.error(f"Port scan results do not contain expected keys: {port_scan}")
        save_to_json(vulnerabilities, domain)
        return render_template('results.html', data=extracted_data, dns_info=dns_info, port_scan=port_scan, vulnerabilities=vulnerabilities)
    except Exception as e:
        logger.error(f"Error analyzing file {filename}: {e}")
        return render_template('error.html', error=str(e))

@app.route('/realtime', methods=['GET', 'POST'])
def realtime():
    if request.method == 'POST':
        target = request.form['target']
        try:
            logger.debug(f"Starting real-time recon for target: {target}")
            socketio.emit('update', {'status': 'Extracting domain...'})
            domain = extract_domain(target)
            socketio.emit('update', {'status': f'Extracted domain: {domain}'})
            socketio.emit('update', {'status': 'Getting DNS info...'})
            dns_info = get_dns_info(domain)
            socketio.emit('update', {'status': f'DNS info: {dns_info}'})
            socketio.emit('update', {'status': 'Performing port scan...'})
            port_scan = perform_port_scan(domain)
            socketio.emit('update', {'status': f'Port scan results: {port_scan}'})

            ip_address = dns_info[0] if dns_info else domain
            if 'scan' in port_scan and ip_address in port_scan['scan'] and 'tcp' in port_scan['scan'][ip_address]:
                vulnerabilities = []
                for port in port_scan['scan'][ip_address]['tcp']:
                    socketio.emit('update', {'status': f'Scanning port {port}...'})
                    vulns = get_vulnerabilities(port, 'darth_daddio', '3p$ALN9$bhVzn6f')
                    vulnerabilities.extend(vulns)
                save_to_json(vulnerabilities, domain)
                socketio.emit('update', {'status': 'Scan complete!', 'vulnerabilities': vulnerabilities})
            else:
                logger.error(f"Port scan results do not contain expected keys: {port_scan}")
                socketio.emit('update', {'status': 'Error', 'error': 'Port scan results do not contain expected keys.'})
        except Exception as e:
            logger.error(f"Error performing real-time recon: {e}")
            socketio.emit('update', {'status': 'Error', 'error': str(e)})
    return render_template('realtime.html')

@socketio.on('start_scan')
def handle_start_scan(data):
    target = data.get('target')
    try:
        logger.debug(f"Starting real-time recon for target: {target}")
        emit('update', {'status': 'Extracting domain...'})
        domain = extract_domain(target)
        emit('update', {'status': f'Extracted domain: {domain}'})
        emit('update', {'status': 'Getting DNS info...'})
        dns_info = get_dns_info(domain)
        emit('update', {'status': f'DNS info: {dns_info}'})
        emit('update', {'status': 'Performing port scan...'})
        port_scan = perform_port_scan(domain)
        emit('update', {'status': f'Port scan results: {port_scan}'})
        
        ip_address = dns_info[0] if dns_info else domain
        if 'scan' in port_scan and ip_address in port_scan['scan'] and 'tcp' in port_scan['scan'][ip_address]:
            vulnerabilities = []
            for port in port_scan['scan'][ip_address]['tcp']:
                emit('update', {'status': f'Scanning port {port}...'})
                vulns = get_vulnerabilities(port, 'darth_daddio', '3p$ALN9$bhVzn6f')
                vulnerabilities.extend(vulns)
            save_to_json(vulnerabilities, domain)
            emit('update', {'status': 'Scan complete!', 'vulnerabilities': vulnerabilities})
        else:
            logger.error(f"Port scan results do not contain expected keys: {port_scan}")
            emit('update', {'status': 'Error', 'error': 'Port scan results do not contain expected keys.'})
    except Exception as e:
        logger.error(f"Error performing real-time recon: {e}")
        emit('update', {'status': 'Error', 'error': str(e)})

def load_json(file_path):
    logger.debug(f"Loading JSON file from: {file_path}")
    with open(file_path, 'r') as file:
        return json.load(file)

def extract_data(data):
    logger.debug(f"Extracting data from: {data}")
    return {'url': data.get('url')}

def get_dns_info(domain):
    logger.debug(f"Getting DNS info for domain: {domain}")
    resolver = dns.resolver.Resolver()
    answer = resolver.resolve(domain, 'A')
    dns_info = [rdata.to_text() for rdata in answer]
    logger.debug(f"DNS info: {dns_info}")
    return dns_info

if __name__ == '__main__':
    socketio.run(app, debug=True)
